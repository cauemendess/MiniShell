# VALGRIND FLAGS:
# valgrind --trace-children=yes --leak-check=full --show-leak-kinds=all --track-fds=yes --trace-children-skip=''*/bin/*,*/sbin/*'' --suppressions=suppressions.supp ./minishell
#-------------------------------------------------------------------------------
# TO DO:
# 1 - ambiguous redirect

#-------------------------------------------------------------------------------
# ERROS:
# 1 - Exemplo que gera o erro
echo < nao_existe < arquivo_invalido mensagem do echo # Está executando o echo
cat < nao_existe < arquivo_invalido < Makefile # Está executando o cat com o Makefile como input (sendo que não era para executar)
# Resolução
No momento que tiver um erro em qualquer redirect (que está sendo validado em um único comando), não valido os outros, apenas para de validar os redirects.
---> Se parar de validar, continuar removendo todos os redirects do comando de qualquer forma (porque o resto do código depende disso)
---> Se parar de validar, não dar free e deixar a struct com o valor do fd sendo -1 (facilita para não executar o comando)
# Sugestão
Fazer a função que valida o redir retornar um int/t_bool pra saber se deu bom
Depois checar se vai dar leak, pois a verificação de fds dos redirects que eu add no exec_one_cmd só da "return" em caso de erro

2 - Variável vazia seguida de comando válido
$jdfhsjdfh echo oi
output mini: Command not found
output bash: oi

Teste:
https://github.com/LucasKuhn/minishell_tester

#--------------------------------------------------------------------------------
# PRINTS AUXILIARES:

# ENV STACK
# void	ft_print_env(void)
# {
# 	int		i;
# 	t_env	*stack;
# 	stack = get_core()->env_list;
# 	i = 0;
# 	while (stack)
# 	{
# 		printf("-----------------------------\n");
# 		printf("| Key  [%d]:%s.\n", i, stack->key);
# 		printf("| Value[%d]:%s.\n", i, stack->value);
# 		printf("| Next [%d]:%p\n", i, stack->next);
# 		printf("-----------------------------\n");
# 		i++;
# 		stack = stack->next;
# 	}
# }

# TOKEN TYPE
# void	ft_translate_type(int type, int i)
# {
# 	printf("| Type [%d]:", i);
# 	if (type == 1)
# 		printf("WORD \n");
# 	else if (type == 2)
# 		printf("REDIRECT \n");
# 	else if (type == 3)
# 		printf("APPEND \n");
# 	else if (type == 4)
# 		printf("PIPE \n");
# 	else if (type == 5)
# 		printf("HEREDOC \n");
# 	else if (type == 6)
# 		printf("SPACES \n");
# 	else if (type == 7)
# 		printf("VAR\n");
# 	else if (type == 8)
# 		printf("TRUNC \n");
# 	else if (type == 9)
# 		printf("END \n");
# }

# TOKEN STACK
# void	ft_print_stack(void)
# {
# 	int		i;
# 	t_token	*stack;
# 	stack = get_core()->token;
# 	i = 0;
# 	while (stack)
# 	{
# 		printf("-----------------------------\n");
# 		printf("| Token[%d]:%s.\n", i, stack->str);
# 		ft_translate_type(stack->token, i);
# 		printf("| Next [%d]:%p\n", i, stack->next);
# 		printf("| Prev [%d]:%p\n", i, stack->prev);
# 		printf("-----------------------------\n");
# 		i++;
# 		stack = stack->next;
# 	}
# }

# CMD TABLE
# void	print_cmd_table(void)
# {
# 	int		i = 0;
# 	t_cmd	*temp;

# 	temp = get_core()->cmd_table;
# 	while (i < get_core()->cmd_table_len)
# 	{
# 		printf("Printando o comando %d: \n", i);
# 		printf("Comando: %s\n", temp[i].cmd);
# 		print_matrix(temp[i].args);
# 		printf("Builtin? %d\n", temp[i].is_builtin);
# 		printf("---------------\n\n\n\n");
# 		i++;
# 	}	
# }

# MATRIX
# void print_matrix(char **matrix)
# {
# 	for(int i = 0; matrix[i] != NULL; i++)
# 		printf("%s\n", matrix[i]);
# 	printf("NULLLLLLLLL\n\n");
# }

# ENV LIST
# void print_env_list()
# {
# 	t_env *env_temp;
# 	env_temp = get_core()->env_list;
# 	while(env_temp != NULL)
# 	{
# 		printf("%s=%s\n", env_temp->key, env_temp->value);
# 		env_temp = env_temp->next;
# 	}
# }

